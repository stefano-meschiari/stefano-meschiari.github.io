<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stefano Meschiari</title>
    <description>Stefano Meschiari's personal website.
</description>
    <link>http://www.stefanom.io//</link>
    <atom:link href="http://www.stefanom.io//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 27 Mar 2021 13:54:48 -0700</pubDate>
    <lastBuildDate>Sat, 27 Mar 2021 13:54:48 -0700</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>Learning under Concept Drift: ML during interesting times</title>
        <description>&lt;p&gt;It’s very rare for both the underlying generative processes that produce the &lt;span class=&quot;with-tooltip&quot; data-tooltip=&quot;server accesses, yearly sales, movie ratings, ...&quot;&gt;raw data&lt;/span&gt;, and the &lt;span class=&quot;with-tooltip&quot; data-tooltip=&quot;APIs, software, cloud services, ...&quot;&gt;systems&lt;/span&gt; we use to measure, transform, and store that raw data, to be static and unchanging. More commonly, they evolve: distributions shift, relationships and constraints between the different dimensions of the data drift and break, data stops being available, and assumptions about the semantics of certain attributes cease to be valid. Multiple of those shifts can be happening on different timescales, and sometimes in abrupt ways.&lt;/p&gt;

&lt;p&gt;This can have a profound effect on machine learning models. An underlying assumption of machine learning models is that the state of the world observed at training time is representative of the environment at which the model is deployed (typically, some time after training). When that assumption is invalid, &lt;em&gt;in the best case scenario&lt;/em&gt;, predictive performance might be degraded; a monitoring component might be able to detect this regression, attribute it to a specific root cause, and trigger a retrain using a different dataset. In the worst case, it will continue to silently, happily serve non-sensical results.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Below, I wrote some notes about how concept drift is defined, how it is detected, and how ML systems can cope with it.&lt;/p&gt;

&lt;h2 id=&quot;what-is-concept-drift&quot;&gt;What is concept drift?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Concept drift&lt;/strong&gt; is a shift in the relationship between covariates ($X$; the features used in the model) and the target variable ($y$; the variable being modeled). The “concept” in the name is the latent &lt;em&gt;context&lt;/em&gt; that defined that relationship.&lt;/p&gt;

&lt;p&gt;Concept drift can be characterized by comparing the &lt;em&gt;joint distribution&lt;/em&gt; $p(X, y)$ of the test dataset, and assessing how much it changed compared to a reference dataset. It also encompasses &lt;span data-tooltip=&quot;i.e. changing p(X)&quot;&gt;data drift&lt;/span&gt; and &lt;span data-tooltip=&quot;i.e. changing p(y)&quot;&gt;label shift&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/blog/concept_drift/types_of_drift.png&quot; alt=&quot;types of drift&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;caption&quot;&gt;Four structural types of drift. Žliobaitė, “Learning under Concept Drift.”&lt;/div&gt;

&lt;p&gt;In &lt;sup id=&quot;fnref:zliobaite&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:zliobaite&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, concept drift encompasses:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a sudden change in context, where the data changed abruptly due to discontinuous changes in the data generation mechanism;&lt;/li&gt;
  &lt;li&gt;a gradual drift, where a new contexts is gradually introduced;&lt;/li&gt;
  &lt;li&gt;an incremental drift, where the context smoothly transitions to a new baseline;&lt;/li&gt;
  &lt;li&gt;a periodic drift, where a context might periodically be reintroduced.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In a &lt;em&gt;supervised&lt;/em&gt; domain (where the label $y$ is known immediately, or close to), concept drift typically manifests itself in reduced predictive performance. More often, concept drift happens in an &lt;em&gt;unsupervised&lt;/em&gt; domain: at inference time, once the model is deployed, we might have access to only a small subset of labels, or they are only captured after substantial latency. Because of that, the problem might not become apparent for some time; all the while, the model has been serving incorrect predictions due to concept drift.&lt;/p&gt;

&lt;p&gt;Furthermore, the lack of labels presents an additional hurdle. Take a fraud detection problem: certain fraudulent behaviors might masquerade as benign by mimicking benign behavior observed in the train dataset. The features might not have changed, but the &lt;em&gt;relationship&lt;/em&gt; of the model features and the (now latent) concept of fraud has.&lt;/p&gt;

&lt;h2 id=&quot;measuring-concept-drift&quot;&gt;Measuring concept drift&lt;/h2&gt;

&lt;h3 id=&quot;distance-between-distributions&quot;&gt;Distance between distributions&lt;/h3&gt;
&lt;p&gt;There are several techniques for measuring concept drift proposed in the literature. A typical heuristic consists of measuring the difference in the probability distribution of the data, as sampled within a &lt;em&gt;reference&lt;/em&gt; window and a &lt;em&gt;test&lt;/em&gt; window spanning a later time range. To fully capture different types of concept drift, a variety of window layouts and sizes should be selected. &lt;em&gt;Adjacent sliding windows&lt;/em&gt; (where the reference and test windows are one after the other) measure recent, abrupt change, while &lt;em&gt;fix-slide windows&lt;/em&gt; compare a fixed reference window and a sliding window, measuring longer-term drift.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/blog/concept_drift/windows.png&quot; alt=&quot;Two different setups for windows&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;caption&quot;&gt;Different setups for laying out a reference (blue) and test (orange) window.&lt;/div&gt;

&lt;p&gt;&lt;sup id=&quot;fnref:dasu&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:dasu&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; propose the &lt;a href=&quot;https://en.wikipedia.org/wiki/Kullback–Leibler_divergence&quot;&gt;Kullback-Leibler (KL) divergence&lt;/a&gt; to quantify the “distance” between the two distributions. Briefly, for two distributions $p$ and $q$, the KL-divergence measures the expectation value of the logarithmic difference between them, weighted by $p$:&lt;/p&gt;

\[D(p\|q) = \sum_x p(x) \log_2\frac{p(x)}{q(x)}\]

&lt;p&gt;Concretely, one could assign $p$ as the distribution of the variable(s) of interest within the reference window, and $q$ with the test window.&lt;/p&gt;

&lt;p&gt;Things to note about the KL divergence:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;it is non-parametric;&lt;/li&gt;
  &lt;li&gt;it is not symmetric between $p$ and $q$;&lt;/li&gt;
  &lt;li&gt;it diverges to infinity when $p \neq 0, q = 0$, which can interpreted as “an event that was deemed as possible by $p$ is impossible per $q$, therefore these distributions are maximally different”.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In practice, the latter situation often happens when sampling a distribution from a finite dataset; in that case, one should &lt;em&gt;smooth&lt;/em&gt; the distribution to account for unseen values. This is concretely done by adding “pseudocounts” to every bin.&lt;/p&gt;

&lt;p&gt;In R, the &lt;a href=&quot;https://www.rdocumentation.org/packages/entropy/versions/1.2.1/topics/entropy.Dirichlet&quot;&gt;entropy&lt;/a&gt; package implements the function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KL.Dirichlet&lt;/code&gt; which computes the KL-divergence with added pseudocounts.&lt;/p&gt;

&lt;p&gt;An alternative measure to the KL divergence is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Jensen–Shannon_divergence&quot;&gt;Jensen-Shannon (JS) divergence&lt;/a&gt;. The JS divergence is a smoothed, symmetrized version of the KL divergence, defined as:&lt;/p&gt;

\[JS(p \| q) = \frac{KL(p \| \frac{p+q}{2}) + KL(q \| \frac{p+q}{2})}{2}\]

&lt;p&gt;The JS divergence is bounded within $0 \leq JS \leq 1$, and does not diverge when one of the distributions is zero (or close to zero) and the other is non-zero.&lt;/p&gt;

&lt;p&gt;It can be trivially implemented using the KL divergence formula:&lt;/p&gt;

&lt;div class=&quot;language-r highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entropy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Returns the empirical JS distance between two&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# vectors of counts.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JS_empirical&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freqs.empirical&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freqs.empirical&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fm&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KL.plugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;log2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
           &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KL.plugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;log2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;comparing-performance-of-learners&quot;&gt;Comparing performance of learners&lt;/h3&gt;
&lt;p&gt;Another option for detecting concept drift – if labels are available – is to keep track of performance metrics of models on unseen data, such as AUC/AUPR, F1, and Brier scores.&lt;/p&gt;

&lt;p&gt;&lt;sup id=&quot;fnref:bach&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:bach&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; proposes a system that pairs two online learners: a &lt;em&gt;stable&lt;/em&gt; learner $S$, trained on a growing window of data encompassing all the examples seen up to time $t$, and a &lt;em&gt;reactive&lt;/em&gt; learner $R_w$ trained on a sliding window of fixed length $w$. The stable learner outperforms the reactive learner as long as the concept is constant, but will start mispredicting as the data transitions to a new concept. Since $R_w$ is trained on a smaller window, it can react more quickly and act as a lagging indicator of drift.&lt;/p&gt;

&lt;p&gt;As a heuristic, the system keeps track of the number of incoming examples predicted correctly by $R_w$ and incorrectly by $S$; once that number passes a certain threshold, the training window of $S$ is clipped to be the same as $R$ before starting to grow again.&lt;/p&gt;

&lt;h2 id=&quot;taking-action&quot;&gt;Taking action&lt;/h2&gt;
&lt;p&gt;Once a way to recognize concept drift has been established, a threshold should be chosen to establish the &lt;em&gt;significance&lt;/em&gt; of the change, in order to distinguish actual drift from random noise.&lt;/p&gt;

&lt;p&gt;When that bar is reached, and we conclude that concept drift is happening, a variety of automated strategies could be set up:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;retraining the model;&lt;/li&gt;
  &lt;li&gt;reducing the size of the training data, to reduce the “inertia” of the model and respond more quickly to change;&lt;/li&gt;
  &lt;li&gt;weighting recent samples more heavily;&lt;/li&gt;
  &lt;li&gt;if the drift is known to be periodic, inducing that knowledge in the model. For instance, if a new cohort of customers is onboarded every three months, it can be helpful to include a time-dependent term in the model, or sample training examples from a longer baseline.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;references&quot;&gt;References&lt;/h1&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:zliobaite&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Žliobaitė, “Learning under Concept Drift.” &lt;a href=&quot;#fnref:zliobaite&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:dasu&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Dasu, “An Information-Theoretic Approach to Detecting Changes in MultiDimensional Data Streams.” &lt;a href=&quot;#fnref:dasu&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:bach&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Bach and Maloof, “Paired Learners for Concept Drift.” &lt;a href=&quot;#fnref:bach&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 25 Feb 2021 00:00:00 -0800</pubDate>
        <link>http://www.stefanom.io//notes/2021/02/25/concept_drift.html</link>
        <guid isPermaLink="true">http://www.stefanom.io//notes/2021/02/25/concept_drift.html</guid>
        
        <category>machine_learning</category>
        
        <category>concept_drift</category>
        
        <category>kl_divergence</category>
        
        
        <category>notes</category>
        
      </item>
    
      <item>
        <title>Rarity of Jupiter-like planets means planetary systems exactly like ours may be scarce</title>
        <description>&lt;p&gt;[&lt;em&gt;This short article I wrote has been published on &lt;a href=&quot;https://theconversation.com/rarity-of-jupiter-like-planets-means-planetary-systems-exactly-like-ours-may-be-scarce-52116&quot; target=&quot;_blank&quot;&gt;The Conversation&lt;/a&gt;  UK.&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;Is our little corner of the galaxy a special place? As of this date, we’ve &lt;a href=&quot;http://exoplanets.org&quot;&gt;discovered more than 1,500 exoplanets&lt;/a&gt;: planets orbiting stars other than our sun. Thousands more will be added to the list in the coming years as we confirm planetary candidates by alternative, independent methods.&lt;/p&gt;

&lt;p&gt;In the hunt for other planets, we’re especially interested in those that might potentially host life. So we focus our modern exoplanet surveys on planets that might be similar to Earth: low-mass, rocky and with just the right temperature to allow for liquid water. But what about the other planets in the solar system? The &lt;a href=&quot;https://en.wikipedia.org/wiki/Copernican_principle&quot;&gt;Copernican principle&lt;/a&gt; – the idea that the Earth and the solar system are not unique or special in the universe – suggests the architecture of our planetary system should be common. But it doesn’t seem to be.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;https://62e528761d0685343e1c-f3d1b99a743ffa4142d9d7f1978d9686.ssl.cf2.rackcdn.com/files/105306/width668/image-20151210-7425-1kd373r.png&quot; alt=&quot;A mass-period diagram. Each dot marks the mass and orbital period of a confirmed exoplanet.&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;caption&quot;&gt;A mass-period diagram. Each dot marks the mass and orbital period of a confirmed exoplanet.&lt;/div&gt;

&lt;p&gt;The figure above, called a &lt;em&gt;mass-period diagram&lt;/em&gt;, provides a visual way to compare the planets of our solar system with those we’ve spotted farther away. It charts the orbital periods (the time it takes for a planet to make one trip around its central star) and the masses of the planets discovered so far, compared with the properties of solar system planets.&lt;/p&gt;

&lt;p&gt;Planets like Earth, Jupiter, Saturn and Uranus occupy “empty” parts of the diagram – we haven’t found other planets with similar masses and orbits so far. At face value, this would indicate that the majority of planetary systems do not resemble our own solar system.&lt;/p&gt;

&lt;p&gt;The solar system lacks close-in planets (planets with orbital periods between a few and a few tens of days) and super-Earths (a class of planets with masses a few times the mass of the Earth often detected in other planetary systems). On the other hand, it does feature several long-period gaseous planets with very nearly circular orbits (Jupiter, Saturn, Uranus and Neptune).&lt;/p&gt;

&lt;p&gt;Part of this difference is due to selection effects: close-in, massive planets are easier to discover than far-out, low-mass planets. In light of this discovery bias, astronomers &lt;a href=&quot;http://aasnova.org/2015/09/25/how-normal-is-our-solar-system/&quot;&gt;Rebecca Martin and Mario Livio&lt;/a&gt; convincingly argue that our solar system is actually &lt;a href=&quot;http://dx.doi.org/10.1088/0004-637X/810/2/105&quot;&gt;more typical than it seems at first glance&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There is a sticking point, however: Jupiter still stands out. It’s an outlier based both on its orbital location (with a corresponding period of about 12 years) and its very-close-to-circular orbit. Understanding whether Jupiter’s relative uniqueness is a real feature, or another product of selection effects, has real implications for our understanding of exoplanets.&lt;/p&gt;
&lt;figure&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/3afEX8a2jPg?wmode=transparent&amp;amp;start=0&quot; width=&quot;440&quot; height=&quot;260&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;allowfullscreen&quot;&gt;&lt;/iframe&gt;&lt;/figure&gt;
&lt;div class=&quot;caption&quot;&gt;Jupiter as seen by the Hubble Space Telescope.&lt;/div&gt;

&lt;h2&gt;Throwing its weight around&lt;/h2&gt;
&lt;p&gt;According to our understanding of how our solar system formed, Jupiter shaped much of the other planets’ early history. Due to its gravity, it influenced the &lt;a href=&quot;http://www.sciencedaily.com/releases/2011/06/110605132437.htm&quot;&gt;formation of Mars&lt;/a&gt; and Saturn. It potentially facilitated the development of life by shielding Earth from cosmic collisions that would have delayed or extinguished it, and by funneling water-rich bodies towards it. And its gravity &lt;a href=&quot;http://doi.org/10.1073/pnas.1423252112&quot;&gt;likely swept the inner solar system of solid debris&lt;/a&gt;. Thanks to this clearing action, Jupiter might have prevented the formation of super-Earth planets with massive atmospheres, thereby ensuring that the inner solar system is populated with small, rocky planets with thin atmospheres.&lt;/p&gt;

&lt;p&gt;Without Jupiter, it looks unlikely that we’d be here. As a consequence, figuring out if Jupiter is a relatively common type of planet might be crucial to understanding whether terrestrial planets with a similar formation environment as Earth are abundant in the galaxy.&lt;/p&gt;

&lt;p&gt;Despite their relative heft, it’s a challenge to discover Jupiter analogs – those planets with periods and masses similar to Jupiter’s. Astronomers typically discover them using an indirect detection technique called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Doppler_spectroscopy&quot;&gt;Doppler radial velocity method&lt;/a&gt;. The gravitational pull of the planet causes tiny shifts in the wavelength of features in the spectrum of the star, in a distinctive, periodic pattern. We can detect these shifts by periodically capturing the star’s light with a telescope and turning it into a spectrum with &lt;a href=&quot;https://www2.keck.hawaii.edu/inst/hires/&quot;&gt;a spectrograph&lt;/a&gt;. This periodic signal, based on a planet’s long orbital period, can require monitoring a star over many years, even decades.&lt;/p&gt;
&lt;h1&gt;Are Jupiter-like planets rare?&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://arxiv.org/abs/1512.00417&quot;&gt;In a recent paper&lt;/a&gt;, Dominick Rowan, a high school senior from New York, and his coauthors (including astronomers from the University of Texas, the University of California at Santa Cruz and me) analyzed the Doppler data for more than 1,100 stars. Each star was observed with the &lt;a href=&quot;http://www.keckobservatory.org/&quot;&gt;Keck Observatory telescope&lt;/a&gt; in Hawaii; many of them had been monitored for a decade or more. To analyze the data, he used the &lt;a href=&quot;https://www.r-project.org&quot;&gt;open-source statistical environment R&lt;/a&gt; together with a freely available application that I developed, called &lt;a href=&quot;http://www.stefanom.org/systemic&quot;&gt;Systemic&lt;/a&gt;. Many universities use an &lt;a href=&quot;http://www.stefanom.org/systemic-live&quot;&gt;online version&lt;/a&gt; to teach how to analyze astronomical data.&lt;/p&gt;

&lt;p&gt;Our team studied the available data for each star and calculated the probability that a Jupiter-like planet could have been missed – either because not enough data are available, or because the data are not of high enough quality. To do this, we simulated hundreds of millions of possible scenarios. Each was created with a computer algorithm and represents a set of alternative possible observations. This procedure makes it possible to infer how many Jupiter analogs (both discovered and undiscovered) orbited the sample of 1,100 stars.
&lt;img src=&quot;https://62e528761d0685343e1c-f3d1b99a743ffa4142d9d7f1978d9686.ssl.cf2.rackcdn.com/files/105134/width668/image-20151209-15552-1nqxyfv.png&quot; alt=&quot;Orbit of the newly discovered Jupiter-mass planet orbiting the star HD 32963, compared to the orbits of Earth and Jupiter around the sun.&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;caption&quot;&gt;Orbit of the newly discovered Jupiter-mass planet orbiting the star HD 32963, compared to the orbits of Earth and Jupiter around the Sun.&lt;/div&gt;

&lt;p&gt;While carrying out this analysis, we discovered a &lt;a href=&quot;http://exoplanet.eu/catalog/hd_32963_b/&quot;&gt;new Jupiter-like planet&lt;/a&gt; orbiting HD 32963, which is a star very similar to the sun in terms of age and physical properties. To make this discovery, we analyzed each star with an automated algorithm that tried to uncover periodic signals potentially associated with the presence of a planet.&lt;/p&gt;

&lt;p&gt;We pinpointed the frequency of Jupiter analogs across the survey at approximately 3%. This result is broadly consistent with previous estimates, which were based on a smaller set of stars or a different discovery technique. It greatly strengthens earlier predictions because we took &lt;em&gt;decades&lt;/em&gt; of observations into account in the simulations.&lt;/p&gt;

&lt;p&gt;This result has several consequences. First, the relative rarity of Jupiter-like planets indicates that true solar system analogs should themselves be rare. By extension, given the important role that Jupiter played at all stages of the formation of the solar system, Earth-like habitable planets with similar formation history to our solar system will be rare.&lt;/p&gt;

&lt;p&gt;Finally, it also underscores that Jupiter-like planets do not form as readily around stars as other types of planets do. It could be because not enough solid material is available, or because these gas giants migrate closer to the central stars very efficiently. &lt;a href=&quot;http://astrobites.org/2015/08/18/giant-planets-from-far-out-there/&quot;&gt;Recent planet-formation simulations&lt;/a&gt; tentatively bear out the latter explanation.&lt;/p&gt;

&lt;p&gt;Long-running, ongoing surveys will continue to help us understand the architecture of the outer regions of planetary systems. Programs including the Keck planet search and the &lt;a href=&quot;http://arxiv.org/abs/1512.02965&quot;&gt;McDonald Planet Search&lt;/a&gt; have been accumulating data for decades. Discovering ice giants similar to Uranus and Neptune will be even tougher than tracking down these Jupiter analogs. Because of their long orbital periods (84 and 164 years) and the very small Doppler shifts they induce on their central stars (tens of times smaller than a Jupiter-like planet), the detection of Uranus and Neptune analogs lies far in the future.&lt;/p&gt;

&lt;p&gt;This article was originally published on &lt;a href=&quot;http://theconversation.com&quot;&gt;The Conversation&lt;/a&gt;. Read the &lt;a href=&quot;https://theconversation.com/rarity-of-jupiter-like-planets-means-planetary-systems-exactly-like-ours-may-be-scarce-52116&quot;&gt;original article&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Dec 2015 00:00:00 -0800</pubDate>
        <link>http://www.stefanom.io//astronomy/2015/12/13/rarity-of-jupiter-like-planets-means-planetary-systems-exactly-like-ours-may-be-scarce.html</link>
        <guid isPermaLink="true">http://www.stefanom.io//astronomy/2015/12/13/rarity-of-jupiter-like-planets-means-planetary-systems-exactly-like-ours-may-be-scarce.html</guid>
        
        <category>citizen_science</category>
        
        <category>exoplanets</category>
        
        <category>HD32963</category>
        
        <category>planet_formation</category>
        
        <category>R</category>
        
        
        <category>astronomy</category>
        
      </item>
    
      <item>
        <title>AstroTRENDS: Weasel words</title>
        <description>&lt;p&gt;&lt;img alt=&quot;Credit: Cliff&quot; src=&quot;/img/blog/weasel.jpg&quot; /&gt;
I added a bunch of new keywords to &lt;a title=&quot;AstroTRENDS: A new tool to track astronomy topics in the literature&quot; href=&quot;http://www.stefanom.org/astrotrends-a-new-tool-to-track-astronomy-topics-in-the-literature/&quot;&gt;AstroTRENDS&lt;/a&gt;, mostly suggested by friends and people in the community who had read my Facebook post.&lt;/p&gt;

&lt;p&gt;A thought I had yesterday is the following: has the astronomical literature become more speculative, and perhaps less committed to audacious claims, in recent times? It is difficult to test this hypothesis   by merely querying ADS for abstract keywords. It would certainly be better served by a &lt;a href=&quot;http://en.wikipedia.org/wiki/Natural_language_processing&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;natural-language processing&lt;/em&gt;&lt;/a&gt; analysis of the full text, although this is just my uninformed speculation.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;A much simpler way is to search for the so-called “weasel words” (such a funny way of describing them from a non-native speaker POV!). Matthew Might (a CS professor from the University of Utah) has &lt;a href=&quot;http://matt.might.net/articles/shell-scripts-for-passive-voice-weasel-words-duplicates/&quot; target=&quot;_blank&quot;&gt;a really interesting article&lt;/a&gt; about the different abuses of language that are common among technical writers, and he created some automated tools for detecting them. It’s a great read. (There’s even an emacs minor mode called &lt;a href=&quot;https://github.com/bnbeckwith/writegood-mode&quot; target=&quot;_blank&quot;&gt;writegood&lt;/a&gt;  based on his recommendations, which I will be testing for sure). Although I don’t necessarily agree with a strict adherence to all of his points, there are certainly some great pieces of advice there.&lt;/p&gt;

&lt;p&gt;Taking his post as a reference, I added a new “weasel words” pseudo-keyword to AstroTRENDS. The “weasel words” keyword shows the result of an ADS query of refereed abstracts containing the following boolean expression:&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;Could OR Possibly OR Might OR Maybe OR Perhaps OR Quite OR Fairly OR Various OR Very OR Several OR Exceedingly OR Vastly OR Interestingly OR Surprisingly OR Remarkably OR Clearly OR Significantly OR Substantially OR Relatively OR Completely OR Extremely&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;We can &lt;em&gt;easily&lt;/em&gt; disagree on whether using these words in an abstract constitutes “weaseling”, or has any sort of nefarious purpose (I certainly pepper my writing with more than my fair share of those). It is still an interesting exercise to verify whether usage of those words has increased over time. The following plot shows the fraction of articles containing those words (i.e. number of articles containing the words normalized by the total article count) each year.&lt;/p&gt;

&lt;p&gt;Keeping all the caveats above in mind, there is a definite upward, pretty linear-by-eye trend going on. I’m not sure whether it has to do with simple evolution of language and style, less boastful writing, an accident of fate/bug on my part, or some other factor.&lt;/p&gt;

&lt;p&gt;This is of course a super-shallow analysis that would require &lt;em&gt;far&lt;/em&gt; more insight than what I offered in this post, but it’s still intriguing.  I tried to altavista whether this is well-known, but have come empty handed so far. Any ideas?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.stefanom.org/playpen/Trends/keywords/index.php?year1=1970&amp;amp;year2=2013&amp;amp;keyword1=Weasel%20words:%20Could%20OR%20Possibly%20OR%20Might%20OR%20Maybe%20OR%20Perhaps%20OR%20Quite%20OR%20Fairly%20OR%20Various%20OR%20Very%20OR%20Several%20OR%20Exceedingly%20OR%20Vastly%20OR%20Interestingly%20OR%20Surprisingly%20OR%20Remarkably%20OR%20Clearly%20OR%20Significantly%20OR%20Substantially%20OR%20Relatively%20OR%20Completely%20OR%20Extremely&amp;amp;normalize=5&quot; target=&quot;_blank&quot;&gt;You can play with the interactive plot itself by clicking this link.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;UPDATE: &lt;a href=&quot;http://mingus.as.arizona.edu/~bjw/&quot; target=&quot;_blank&quot;&gt;Ben Weiner&lt;/a&gt;  made a really good point on the Facebook astronomer group.     He suggests that an additional, alternative explanation could simply be that abstracts have become, on average, more verbose with time, which would explain the higher frequency of fluffy adjectives and adverbs. This could be checked with a control set of non-weasel words… which I will definitely try.&lt;/p&gt;

&lt;p&gt;How did this post do with &lt;a href=&quot;https://github.com/bnbeckwith/writegood-mode&quot; target=&quot;_blank&quot;&gt;writegood-mode&lt;/a&gt;? Pretty nicely… but I got a grade of “11” on &lt;a href=&quot;http://www.hemingwayapp.com&quot; target=&quot;_blank&quot;&gt;Hemingway&lt;/a&gt;, with about 9 out 24 sentences being &lt;em&gt;hard to read&lt;/em&gt;.   Oh well.&lt;/p&gt;
</description>
        <pubDate>Sun, 15 Feb 2015 00:00:00 -0800</pubDate>
        <link>http://www.stefanom.io//astronomy/2015/02/15/astrotrends-weasel-words.html</link>
        <guid isPermaLink="true">http://www.stefanom.io//astronomy/2015/02/15/astrotrends-weasel-words.html</guid>
        
        
        <category>astronomy</category>
        
      </item>
    
      <item>
        <title>Colliding N-body spheres: Particle Mayhem!
</title>
        <description>&lt;iframe style=&quot;display: block; margin:auto; border: 1px solid silver;&quot; src=&quot;/public/wgc/test_nbody.html?v=0&quot; width=&quot;600&quot; height=&quot;800&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;When Giants Collide — WGC for short — is one of the “fun” projects I am working on. Once finished, it will be a small in-browser simulator where you can collide giant planets together (with some degree of realism). You can see my progress on my &lt;a href=&quot;https://github.com/stefano-meschiari/WhenGiantsCollide&quot;&gt;GitHub repo&lt;/a&gt; and the series of &lt;a href=&quot;http://www.stefanom.org/category/when-giants-collide/&quot; target=&quot;_blank&quot;&gt;blog posts under this category.&lt;/a&gt;&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;In this little demo app, you can run an N-body simulation in your browser where you make two spheres made of point masses “collide”. You can tweak various parameters (collision speed,  impact parameter, distance and number of particles) to change the outcome of the simulation.&lt;/p&gt;

&lt;h3&gt;Underneath it all: TreeSPH.js&lt;/h3&gt;
&lt;p&gt;The app above is powered by the portion of WGC’s code that computes the gravitational force between a set of point particles (&lt;a href=&quot;http://www.scholarpedia.org/article/N-body_simulations_(gravitational)&quot; target=&quot;_blank&quot;&gt;a gravitational N-body system&lt;/a&gt;). The gravitational force is computed using the &lt;a title=&quot;An interactive Barnes-Hut tree&quot; href=&quot;http://www.stefanom.org/bh-tree/&quot; target=&quot;_blank&quot;&gt;Barnes-Hut tree gravity algorithm&lt;/a&gt;, and the coordinates of the points are evolved using a third-order embedded Runge-Kutta algorithm. The code is available in the &lt;a href=&quot;https://github.com/stefano-meschiari/WhenGiantsCollide&quot; target=&quot;_blank&quot;&gt;GitHub repo&lt;/a&gt; for WGC.&lt;/p&gt;

&lt;p&gt;I am now working on writing the hydrodynamical part (via the &lt;a href=&quot;http://en.wikipedia.org/wiki/Smoothed-particle_hydrodynamics&quot; target=&quot;_blank&quot;&gt;SPH algorithm&lt;/a&gt;), which will let me simulate the collision between two gaseous spheres. The resulting library will be called &lt;strong&gt;treesph.js&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;treesph.js &lt;/strong&gt;will be an open-source JavaScript library able to power small-scale hydrodynamical simulations — either in the browser (through web workers), or within a JavaScript environment (e.g. Node.js). It comes with:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;a library to set up initial equilibrium conditions (e.g. Lane-Emden spheres, or N-body spheres with isotropic velocity dispersion);&lt;/li&gt;
  &lt;li&gt;a canvas-based library to plot and animate the simulation snapshots;&lt;/li&gt;
  &lt;li&gt;a fast library for operating on vectors and matrices that minimizes allocations and copying, and other math routines.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Performance notes&lt;/h3&gt;
&lt;p&gt;While playing with the app, you may be wondering (a) why there is a “buffering” stage before you can see the evolution of the system, and (b) why so few particles?&lt;/p&gt;
&lt;h4&gt;Buffering: it's all about delayed gratification&lt;/h4&gt;
&lt;p&gt;The app animates the particle motion at 30 frames per second. This requirement places a hard and fast constraint: if you want to compute the particle motion at each frame request, then the computation must take less than 1/30th of a second, otherwise the webpage will freeze as the JavaScript engine tries to catch up with the accumulated frame requests. For reasonable number of particles (say, 100 or more — see below) and the time steps required by the above app, this requirement is &lt;em&gt;way &lt;/em&gt;overshot.&lt;/p&gt;

&lt;p&gt;This issue can be ameliorated by running the numerical computation in a separate thread (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/Performance/Using_web_workers&quot; target=&quot;_blank&quot;&gt;a web worker&lt;/a&gt;), and drawing frames on the main thread as soon as they are computed. This is still not as optimal: while it solves the UI freezing issue, the particle motion will appear very jerky as it will be animated at (typically) less than a frame per second!&lt;/p&gt;

&lt;p&gt;In order to solve this issue, I created a small JavaScript library (&lt;strong&gt;streamingcontroller.js&lt;/strong&gt;; available in the same &lt;a href=&quot;https://github.com/stefano-meschiari/WhenGiantsCollide&quot; target=&quot;_blank&quot;&gt;GitHub repo&lt;/a&gt;, documentation upcoming). &lt;strong&gt;Streamingcontroller.js &lt;/strong&gt;first estimates the expected wall time — the time in seconds — needed to complete the simulation. Then, within the web worker thread, it “buffers” the simulation snapshots by adding them to a pool of snapshots. Once the buffer is big enough that the simulation can be run in real time without hiccups, the library starts streaming the snapshots back to the main thread where the animation is drawn. In the main thread, a second buffer receives the snapshots; the second buffer is then emptied at 30 frames per second.&lt;/p&gt;
&lt;h4&gt;More particles, pretty please?&lt;/h4&gt;
&lt;p&gt;The default setting of the app is to animate 250 particles (125 per sphere). Why so few, when typical number of particles quoted for &lt;em&gt;N&lt;/em&gt;-body simulations routinely exceed millions — or &lt;a href=&quot;http://www.mpa-garching.mpg.de/galform/virgo/millennium/index.shtml&quot; target=&quot;_blank&quot;&gt;even billions!&lt;/a&gt; — of particles?&lt;/p&gt;

&lt;p&gt;There are three bottlenecks at work. The first is obvious: the code isn’t fully optimized and profiled yet, and I am certain there is room for improvement. I am writing a small math library of common mathematical routines called &lt;strong&gt;math.js &lt;/strong&gt;(also in the same &lt;a href=&quot;https://github.com/stefano-meschiari/WhenGiantsCollide&quot; target=&quot;_blank&quot;&gt;GitHub repo&lt;/a&gt;) which will be fully optimized for V8.&lt;/p&gt;

&lt;p&gt;The second is also obvious: simulations with lots of particles are usually run at full-speed, on multiple cores, and in the background. These simulations can save their snapshots, to be plotted and animated at the end of the run. An online app (or game) with real-time requirements (or, say, a &amp;lt;1 minute buffering time) doesn’t have this kind of luxury!&lt;/p&gt;

&lt;p&gt;The third is the worst hurdle, and it is inherent to the nature of JavaScript: &lt;a href=&quot;http://sealedabstract.com/rants/why-mobile-web-apps-are-slow/&quot; target=&quot;_blank&quot;&gt;JavaScript is slow&lt;/a&gt;. I am not a JavaScript guru by any means, but I do have a good amount of experience writing performant numerical code in a variety of languages (mostly C). While JavaScript is typically fast enough for most tasks on the web, it is&lt;i&gt; &lt;/i&gt;&lt;strong&gt;slow&lt;/strong&gt; on personal computers and even &lt;strong&gt;slower&lt;/strong&gt; on mobile platforms for physically-motivated, accurate simulations. In its present form, it is not well-suited to run these kinds of numerical tasks as quickly as the underlying hardware allows. Although JavaScript interpreters have been improving by leaps and bounds, and careful code can exploit some of these optimizations, they are hitting a wall of &lt;a href=&quot;http://sealedabstract.com/wp-content/uploads/2013/07/Screen-Shot-2013-07-09-at-3.59.43-PM.png&quot; target=&quot;_blank&quot;&gt;diminishing returns&lt;/a&gt;. Since JavaScript is the only runtime available on browsers, it is the ultimate bottleneck.&lt;/p&gt;

&lt;p&gt;You can check out the other demos using code from WGC in &lt;a href=&quot;http://www.stefanom.org/wgc&quot; target=&quot;_blank&quot;&gt;this webpage&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 07 Aug 2014 00:00:00 -0700</pubDate>
        <link>http://www.stefanom.io//astronomy/2014/08/07/colliding-n-body-spheres-particle-mayhem.html</link>
        <guid isPermaLink="true">http://www.stefanom.io//astronomy/2014/08/07/colliding-n-body-spheres-particle-mayhem.html</guid>
        
        <category>visualization</category>
        
        <category>when-giants-collide</category>
        
        
        <category>astronomy</category>
        
      </item>
    
      <item>
        <title>A JavaScript benchmark: Barnes-Hut gravity</title>
        <description>&lt;iframe src=&quot;/public/wgc/test_gravity.html?v=0&quot; width=&quot;600&quot; height=&quot;650&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;[&lt;em&gt;Updated on March 2021 with new devices!&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;In one of my last posts (&lt;a href=&quot;/astronomy/2014/07/16/barnes-hut.html&quot;&gt;An interactive Barnes-Hut tree&lt;/a&gt;) I talked briefly about one of the “fun” projects I’m working on, When Giants Collide (work in progress, &lt;a href=&quot;https://github.com/stefano-meschiari/WhenGiantsCollide&quot;&gt;GitHub repo&lt;/a&gt;), and promised myself to blog about its development as I went along. I just finished refining the algorithm for building the tree and calculating the gravitational force.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;The small app above is a benchmark pitting the Barnes-Hut algorithm for computing gravity (&lt;a href=&quot;http://en.wikipedia.org/wiki/Barnes–Hut_simulation&quot; target=&quot;_blank&quot;&gt;an O(N log(N)) algorithm&lt;/a&gt;) against a brute-force direct summation (an O(N^2) algorithm). It calculates the gravitational field of a random collection of particles using both methods for N = 256 to N = 16,384; a lower amount of time spent indicates a faster algorithm. The time used to compute the gravitational force is averaged over 12 iterations to minimize fluctuations. Results are plotted in real time. Try to toggle the logarithmic axis to see the actual difference between an $O(N^2)$ and an $O(N \log N)$ algorithm!&lt;/p&gt;

&lt;p&gt;Lastly, it calculates an overall “score” for the JavaScript interpreter by only running the Barnes-Hut algorithm for N = 16,384. You can see a table of scores for a few different browsers and devices I have access to (lower is better). If you’d like, &lt;a href=&quot;mailto:stefano.meschiari@gmail.com&quot;&gt;send me your score&lt;/a&gt;!&lt;/p&gt;

&lt;h3&gt;Scores (lower is better)&lt;/h3&gt;

&lt;table class=&quot;ui celled table structured&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;&lt;th&gt;Device&lt;/th&gt;&lt;th&gt;Running on&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;th&gt;Relative to MacBook Pro, 2012, Chrome 36&lt;/th&gt;&lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;2&quot;&gt;MacBook Air (M1, 2020), 11.2.3&lt;/td&gt;
      &lt;td&gt;Safari 14.0.3&lt;/td&gt;
      &lt;td&gt;5,275&lt;/td&gt;
      &lt;td&gt;0.36x&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Chrome 89&lt;/td&gt;
      &lt;td&gt;6,850&lt;/td&gt;
      &lt;td&gt;0.46x&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;4&quot;&gt;MacBook Pro (Retina, late 2012), 10.9.4&lt;/td&gt;
      &lt;td&gt;Chrome 36&lt;/td&gt;
      &lt;td&gt;14,641&lt;/td&gt;
      &lt;td&gt;1.0x&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Safari 7.0.5&lt;/td&gt;
      &lt;td&gt;17,541&lt;/td&gt;
      &lt;td&gt;1.2x&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Firefox 30&lt;/td&gt;
      &lt;td&gt;18,866&lt;/td&gt;
      &lt;td&gt;1.3x&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Node 0.10.29&lt;/td&gt;
      &lt;td&gt;21,858&lt;/td&gt;
      &lt;td&gt;1.5x&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;2&quot;&gt;iPhone 5S, 7.1.2&lt;/td&gt;
      &lt;td&gt;Safari&lt;/td&gt;
      &lt;td&gt;63,841&lt;/td&gt;
      &lt;td&gt;4.4x&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Mercury (no JIT)&lt;/td&gt;
      &lt;td&gt;561,033&lt;/td&gt;
      &lt;td&gt;38.3x&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone 5C, 7.1.2&lt;/td&gt;
      &lt;td&gt;Safari&lt;/td&gt;
      &lt;td&gt;147,141&lt;/td&gt;
      &lt;td&gt;10.0x&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3&gt;Some observations about JavaScript optimization&lt;/h3&gt;
&lt;p&gt;Chrome turned out to be the fastest browser at this particular benchmark. Surprisingly, a previous version of the same code was actually the  slowest on my MacBook – almost 6x as slow as Safari! That was quite unexpected, as in my (limited) experience building web apps Chrome tends to edge out other browsers in terms of JavaScript execution speed.&lt;/p&gt;

&lt;p&gt;So I waded a little bit more into my code to understand what was making my code so inefficient. This &lt;a href=&quot;https://developers.google.com/speed/articles/optimizing-javascript&quot; target=&quot;_blank&quot;&gt;Google optimization guide&lt;/a&gt; and &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/speed/v8/&quot; target=&quot;_blank&quot;&gt;this post on HTML5Rocks&lt;/a&gt; (specifically talking about optimizing for V8, the just-in-time compiler embedded in Chrome) proved very useful. What I learned:&lt;/p&gt;
&lt;ol&gt;
 	&lt;li&gt;Use the idiomatic JavaScript style for creating classes (using prototypes, new, straightforward constructors etc.) instead of using an object factory and closures.&lt;/li&gt;
 	&lt;li&gt;Avoid creating closures, when possible.&lt;/li&gt;
 	&lt;li&gt;Use node.js to profile the application and identify functions that are not getting optimized (using &lt;em&gt;--trace-opt&lt;/em&gt;).&lt;/li&gt;
 	&lt;li&gt;Both Safari and Firefox had good baseline scores even &lt;i&gt;before&lt;/i&gt; these optimizations. I found it quite surprising that V8 was much more fastidious about my code than the other JavaScript engines.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Another finding was how much slower alternative browsers (e.g. Chrome, Mercury) are on iOS. Alternative browsers use the same engine as Safari, but they don’t have access to&lt;a href=&quot;http://daringfireball.net/2011/03/nitro_ios_43&quot; target=&quot;_blank&quot;&gt; Nitro’s Just-In-Time compilation&lt;/a&gt; – this means that they will be quite a bit slower than Safari on a computationally-intensive benchmark. How much slower? On my iPhone 5S, almost a factor of 10!&lt;/p&gt;

&lt;h3&gt;Web workers are awesome&lt;/h3&gt;
&lt;p&gt;The benchmark runs in a different thread, so that the page itself remains responsive. This is accomplished using Web Workers, a relatively new technology that allows the page to spin off threads to do computation-heavy work. &lt;a href=&quot;http://caniuse.com/webworkers&quot; target=&quot;_blank&quot;&gt;It’s quite well supported&lt;/a&gt;, and I found it pretty easy to learn (&lt;a href=&quot;http://stackoverflow.com/questions/21408510/chrome-cant-load-web-worker&quot; target=&quot;_blank&quot;&gt;aside from some surprising quirks&lt;/a&gt;). I plan on spinning off some of the tasks in &lt;a title=&quot;Systemic Live&quot; href=&quot;http://www.stefanom.org/systemic-live/&quot;&gt;Systemic Live&lt;/a&gt; – which currently either block the interface or use timers – into Web Workers (it’ll be a quite a bit of work, so don’t hold your breath).&lt;/p&gt;
</description>
        <pubDate>Thu, 24 Jul 2014 00:00:00 -0700</pubDate>
        <link>http://www.stefanom.io//astronomy/2014/07/24/barnes-hut-benchmark.html</link>
        <guid isPermaLink="true">http://www.stefanom.io//astronomy/2014/07/24/barnes-hut-benchmark.html</guid>
        
        <category>astronomy</category>
        
        <category>javascript</category>
        
        <category>gravity</category>
        
        <category>algorithms</category>
        
        <category>benchmark</category>
        
        
        <category>astronomy</category>
        
      </item>
    
      <item>
        <title>An interactive Barnes-Hut tree</title>
        <description>&lt;iframe src=&quot;/public/wgc/test_tree.html?v=0&quot; width=&quot;600&quot; height=&quot;600&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;I’ve recently started experimenting with a new  visualization that I think will turn out pretty darn cool. Its draft name is &lt;a href=&quot;http://en.wikipedia.org/wiki/When_Worlds_Collide&quot; target=&quot;_blank&quot;&gt;When Giants Collide.&lt;/a&gt; When  Giants Collide will address a common request from planetary crashers: “&lt;em&gt;Can I see what happens when two giant planets collide”&lt;/em&gt;?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;When Giants Collide will be a super-simple JavaScript app (so it will run in your browser) that will simulate the collision of two massive spheres of gas. The simulation will have to model both gravity and the dynamics of the gas: to address this, I’ve been dusting off and reviewing an old &lt;a href=&quot;http://en.wikipedia.org/wiki/Smoothed-particle_hydrodynamics&quot; target=&quot;_blank&quot;&gt;Smoothed-Particle Hydrodynamics&lt;/a&gt; (SPH) code I worked on for a brief period in graduate school. SPH is a very simple technique for cheaply simulating gas flows with good spatial accuracy, and is somewhat straightforward to code. There are some shortcuts that have to be taken, too – large time steps, low particle counts, and more (e.g., a polytropic equation of state for the gas giants; more on this in future posts). These shortcuts come at the expense of realism, but will enable fast, smooth animation in the browser.&lt;/p&gt;

&lt;h3&gt;Gravity with the  Barnes-Hut algorithm&lt;/h3&gt;
&lt;p&gt;Gravity is an essential ingredient of When Giants Collide! Even with very low particle counts (say, &lt;em&gt;N &lt;/em&gt;= 1000), a brute force calculation that just sums up the mutual gravitational force between particles won’t do if you want to run the simulation at 60 frames per second. Direct summing is an N^2 operation:
&lt;script src=&quot;https://gist.github.com/stefano-meschiari/875fdfde63eba2cb620d.js&quot;&gt;&lt;/script&gt;
(this is a simple force accumulator written in R).&lt;/p&gt;

&lt;p&gt;A better way that involves only a slightly more complicated algorithm is to use the &lt;a href=&quot;http://adsabs.harvard.edu/abs/1986Natur.324..446B&quot; target=&quot;_blank&quot;&gt;Barnes-Hut algorithm&lt;/a&gt; (a short Nature paper with more than 1,000 citations!). The algorithm involves recursively subdividing space into cubes and loading them with particles, such that every cube contains either 0 or 1 particles. This is represented in code with an oct-tree structure.  Once such a tree is constructed, one can calculate the gravitational force on a given particle in the brute-force way for close particles, and in an approximate way for distant particles; whether to use one or the other is determined by walking the tree down from the top. An excellent explanation (with great visuals!) is provided &lt;a href=&quot;http://arborjs.org/docs/barnes-hut&quot; target=&quot;_blank&quot;&gt;in this article&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The other advantage is that, once the tree has been already built for the gravity calculation, it can be used to identify the nearest neighbors of a given particle through the same tree-walking procedure. The nearest neighbors are needed for the hydrodynamical part of the SPH algorithm (see, e.g., this review article by &lt;a href=&quot;http://adsabs.harvard.edu/abs/2009NewAR..53...78R&quot; target=&quot;_blank&quot;&gt;Stefan Rosswog&lt;/a&gt; or this one by &lt;a href=&quot;http://adsabs.harvard.edu/abs/2012JCoPh.231..759P&quot; target=&quot;_blank&quot;&gt;Daniel Price&lt;/a&gt;).&lt;/p&gt;
&lt;h3&gt;An interactive tree&lt;/h3&gt;
&lt;p&gt;Below is an interactive JavaScript applet that subdivides space with the Barnes-Hut algorithm. You can add new points by clicking on the surface, or using the buttons to add new, random ones.&lt;/p&gt;

&lt;p&gt;The code for building the Barnes-Hut tree from an array of 3D positions is available at the &lt;a href=&quot;https://github.com/stefano-meschiari/WhenGiantsCollide&quot; target=&quot;_blank&quot;&gt;GitHub repository for When Giants Collide.&lt;/a&gt; I will be developing the code in the open, and post periodically about my progress. Hopefully by the end of summer I will have an attractive app running on any modern device and web browser. Any ideas on how to gamify it?&lt;/p&gt;
</description>
        <pubDate>Wed, 16 Jul 2014 00:00:00 -0700</pubDate>
        <link>http://www.stefanom.io//astronomy/2014/07/16/barnes-hut.html</link>
        <guid isPermaLink="true">http://www.stefanom.io//astronomy/2014/07/16/barnes-hut.html</guid>
        
        <category>astronomy</category>
        
        <category>javascript</category>
        
        <category>gravity</category>
        
        <category>algorithms</category>
        
        
        <category>astronomy</category>
        
      </item>
    
      <item>
        <title>The Automated Planet Finder, Systemic and Super Planet Crash</title>
        <description>&lt;p&gt;[&lt;em&gt;This short article I wrote has been published on &lt;a href=&quot;https://theconversation.com/telescope-apps-help-amateurs-hunt-for-exoplanets-24925&quot; target=&quot;_blank&quot;&gt;The Conversation&lt;/a&gt;  UK.&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;The following is a short article about the &lt;a href=&quot;http://news.ucsc.edu/2014/03/apf-telescope.html&quot; target=&quot;_blank&quot;&gt;Automated Planet Finder&lt;/a&gt;, &lt;a href=&quot;/systemic-live&quot; target=&quot;_blank&quot;&gt;Systemic&lt;/a&gt; and &lt;a href=&quot;/spc&quot; target=&quot;_blank&quot;&gt;Super Planet Crash&lt;/a&gt;. We recently announced the first batch of exoplanets that were discovered in the first few months of science operation of APF. The first two systems (&lt;a href=&quot;http://www.oklo.org/HD141399.pdf&quot; target=&quot;_blank&quot;&gt;HD141399&lt;/a&gt; and &lt;a href=&quot;http://www.oklo.org/GL687.pdf&quot; target=&quot;_blank&quot;&gt;Gliese 687&lt;/a&gt;) have been submitted and will be available on astro-ph shortly.&lt;/p&gt;

&lt;!--more--&gt;
&lt;h1&gt;Telescope apps help amateurs hunt for exoplanets&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://62e528761d0685343e1c-f3d1b99a743ffa4142d9d7f1978d9686.ssl.cf2.rackcdn.com/files/45886/width668/q5bhnrtr-1396989823.jpg&quot; /&gt;
&lt;small&gt;&lt;a href=&quot;www.lauriehatch.com&quot; target=&quot;_blank&quot;&gt;Laurie Hatch&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;People around the world are being invited to learn how to hunt for planets, using &lt;a href=&quot;http://mcdonaldobservatory.org/news/releases/2014/04/07&quot;&gt;two new online apps&lt;/a&gt; devised by scientists at the University of Texas at Austin and UC Santa Cruz.&lt;/p&gt;

&lt;p&gt;The apps use data from the &lt;a href=&quot;http://news.ucsc.edu/2014/03/apf-telescope.html&quot;&gt;Automated Planet Finder&lt;/a&gt; (APF), Lick Observatory’s newest telescope. The APF is one of the first &lt;a href=&quot;http://arxiv.org/abs/1402.6684&quot;&gt;robotically operated telescopes&lt;/a&gt; monitoring stars throughout the entire sky. It is optimised for the detection of planets orbiting nearby stars – the so-called exoplanets.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.stefanom.org/systemic-live/&quot;&gt;Systemic&lt;/a&gt; is an app that collects observations from APF and other observatories and makes them available to the general public. Anyone can access a simplified interface and follow the steps that astronomers take to tease a planetary signal out of the tiny Doppler shifts collected by the telescope.&lt;/p&gt;

&lt;p&gt;Students and amateurs can learn about the process of scientific discovery from their own web browsers, and even conduct their own analysis of the data to validate planet discoveries.&lt;/p&gt;

&lt;p&gt;The second app, &lt;a href=&quot;http://www.stefanom.org/spc&quot;&gt;SuperPlanetCrash&lt;/a&gt;, is a simple but addictive game that animates the orbits of planetary systems as a “digital orrery”. Users can play for points and create their own planetary systems, which often end up teetering towards instabilities that eject planets away from their parent stars.&lt;/p&gt;
&lt;h2&gt;First catch&lt;/h2&gt;
&lt;p&gt;Despite only being in operation for a few months, APF has already been used to discover new planetary systems.&lt;/p&gt;

&lt;p&gt;Night after night, the telescope autonomously selects a list of interesting target stars, based on their position in the sky and observing conditions. The telescope collects light from each target star. The light is then split into a rainbow of colours, called a spectrum. Superimposed on the spectrum is a pattern of dark features, called absorption lines, which is unique to the chemical makeup of the star.&lt;/p&gt;

&lt;p&gt;When a planet orbits one of the target stars, its gravitational pull on the star causes the absorption lines to shift back and forth. &lt;a href=&quot;https://www.youtube.com/watch?v=ElU7r4AwUug&quot;&gt;Astronomers can then interpret&lt;/a&gt; the amplitude and periodicity of these shifts to indirectly work out the orbit and the mass of each planet.&lt;/p&gt;

&lt;p&gt;This method of detecting exoplanets is dubbed the Doppler (or Radial Velocity) technique, named after the physical effect causing the shift of the absorption lines. The Doppler technique has been extremely productive over the past two decades, leading to the discovery of more than 400 planet candidates orbiting nearby stars – including the first exoplanet orbiting a star similar to our own Sun, &lt;a href=&quot;http://www.bbc.co.uk/science/space/universe/key_places/51_pegasi&quot;&gt;51 Pegasi&lt;/a&gt;. To conclusively detect a planetary candidate, each star has to be observed for long stretches of time (months to years) in order to rule out other possible explanations.&lt;/p&gt;

&lt;p&gt;The APF has now found two new planetary systems surrounding the stars HD141399 and Gliese 687.&lt;/p&gt;

&lt;p&gt;HD141399 hosts four giant, gaseous planets of comparable size to Jupiter. The orbits of the innermost three giant planets are dramatically more compact than the giant planets in our Solar System (Jupiter, Saturn, Uranus and Neptune).&lt;/p&gt;

&lt;p&gt;Gliese 687 is a small, red star hosting a Neptune-mass planet orbiting very close to the star: it only takes about 40 days for the planet to complete a full revolution around the star.&lt;/p&gt;

&lt;p&gt;Team leader Steve Vogt of the University of California, Santa Cruz has dubbed both of these almost “garden variety” planetary systems, and indeed, they are quite similar to some of the systems discovered over the last few years. However, what look like distinctly unglamorous planetary systems now can still pose a puzzle to scientists.&lt;/p&gt;
&lt;h2&gt;The new normal&lt;/h2&gt;
&lt;p&gt;The planetary systems discovered so far are typically very different from our own solar system. More than half of the nearby stars are thought to be accompanied by Neptune-mass or smaller planets, many orbiting closer than Mercury is to the Sun. In our solar system, on the other hand, there is a very clear demarcation between small, rocky planets close to the Sun (from Mercury to Mars) and giant planets far from the Sun (from Jupiter to Neptune). This perhaps suggests that planetary systems like the one we live in are an uncommon outcome of the process of planet formation.&lt;/p&gt;

&lt;p&gt;Only further discoveries can clarify whether planetary systems architected like our own are as uncommon as they appear to be. These observations will need to span many years of careful collection of Doppler shifts. Since the APF facility is primarily dedicated to Doppler observations, it is expected to make key contributions to exoplanetary science.&lt;/p&gt;

&lt;p&gt;The two apps produced by the APF team make amateur scientists part of the hunt. These applications join the nascent movement of “citizen science”, which enable the general public to understand and even contribute to scientific research, either by lending a hand in &lt;a href=&quot;http://www.planethunters.org&quot;&gt;analyzing massive sets of scientific data&lt;/a&gt; or by &lt;a href=&quot;http://www.milkywayproject.org&quot;&gt;flagging interesting datasets&lt;/a&gt; that warrant further collection of data.&lt;/p&gt;
</description>
        <pubDate>Wed, 16 Apr 2014 00:00:00 -0700</pubDate>
        <link>http://www.stefanom.io//astronomy/2014/04/16/the-automated-planet-finder-systemic-and-super-planet-crash.html</link>
        <guid isPermaLink="true">http://www.stefanom.io//astronomy/2014/04/16/the-automated-planet-finder-systemic-and-super-planet-crash.html</guid>
        
        <category>systemic</category>
        
        <category>spc</category>
        
        <category>telescopes</category>
        
        
        <category>astronomy</category>
        
      </item>
    
  </channel>
</rss>
